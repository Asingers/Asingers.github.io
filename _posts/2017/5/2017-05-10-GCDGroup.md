---
layout: post
title: dispatch_group & semaphore
subtitle: GCD
header-img: http://o6ledomfy.bkt.clouddn.com/20170822150339973257462.jpg
categories: ios
header-mask: 0.4
tags: 
    - iOS
    - 线程
    - GCD
---

`dispatch_group`从名字上也知道他是一个组,他的用法就是把一组任务提交到队列中,然后可以监听这些任务.
常见的方法:

1. `dispatch_group_create`创建一个调度任务组
2. `dispatch_group_async` 把一个任务异步提交到任务组里
3. `dispatch_group_enter/dispatch_group_leave` 这种方式用在不使用dispatch_group_async来提交任务，且必须配合使用
4. `dispatch_group_notify` 用来监听任务组事件的执行完毕
5. `dispatch_group_wait` 设置等待时间，在等待时间结束后，如果还没有执行完任务组，则返回。返回0代表执行成功，非0则执行失败.稍后会提到semaphore的问题

实际的使用场景  
现在有4个任务: 任务1、任务2、任务3、任务4. 且任务3必须在任务2之后，任务4必须在前3个任务都执行完成后，才能执行，并且需要在主线程更新UI。也就是说要控制他们的顺序.

那么也就是:   

任务3必须在任务2之后，所以这两个必须串行执行，同时，任务2和3整体可以和任务1并行执行，最后，任务4只能等待前3个任务全部执行完成，才能执行。

	-(void)disGroup{
    dispatch_queue_t globalQuene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_queue_t selfQuene = dispatch_queue_create("myQuene", 0);
    dispatch_group_t group = dispatch_group_create();
    dispatch_group_async(group, globalQuene, ^{
        NSLog(@"run task 1");
    });
    dispatch_group_async(group, selfQuene, ^{
        NSLog(@"run task 2");
    });
    dispatch_group_async(group, selfQuene, ^{
        NSLog(@"run task 3");
    });
    
    // 这个notify是等到 Group 中都执行完了才会执行
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"run task 4");
   	 });
	}
	
![](http://o6ledomfy.bkt.clouddn.com/20170822150340146014844.jpg)
总结： 1和（2、3）是并行执行关系，2、3是串行执行关系，且3肯定在2之后，而4在（1、2、3）全部完成之后才会执行。

`dispatch_group_enter(group)、dispatch_group_leave(group)`这个用的很少...
这两个方法其实就是：手动管理group关联的block的运行状态（或计数），并且使用时必须保证进入和退出group次数匹配。 AB 其实一样的. 

	A)
	dispatch_group_async(group, queue, ^{
		// 。。。
	});
 
	B)
	dispatch_group_enter(group);
	dispatch_async(queue, ^{
		//。。。
	　　dispatch_group_leave(group);
	});
	
例子:有3个异步请求任务，任务1、2、3，在3个任务全部完成之后，需要执行任务4，用以显示界面数据。

dispatch_queue_t globalQuene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t group = dispatch_group_create();
     
    //任务1
    dispatch_group_enter(group);
    dispatch_async(globalQuene, ^{
         NSLog(@"run task 1");
        sleep(1);
        dispatch_group_leave(group);
    });
     
    //任务2
    dispatch_group_enter(group);
    dispatch_async(globalQuene, ^{
        NSLog(@"run task 2");
        sleep(2);
        dispatch_group_leave(group);
    });
     
    //任务3
    dispatch_group_enter(group);
    dispatch_async(globalQuene, ^{
        NSLog(@"run task 3");
        sleep(3);
        dispatch_group_leave(group);
    });
     
    //一直等待完成
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
   
    //任务3
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"run task 4");
    });

注意看: 这三个任务是异步执行的. 即使顺序可能不同,(当然也可以用串行队列)但可以肯定的是一共用了3秒时间.之后执行4  
![](http://o6ledomfy.bkt.clouddn.com/20170822150340282838652.jpg)
